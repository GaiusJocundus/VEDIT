.cm Last Change: Ted - Oct. 28, 1985
.pw 70
.rm 70
.pi 16
.tm 4
.hm 3
.bm 4
.fm 2
.fo ////
.il `
.he /VEDIT//Page #/
.sh ////
.bp
.sp 8
.ce
`OSC O M M A N D   M O D E`OS
`TCV.~~~~~~~~Command Mode`TC
.bp
.sh /Command Mode///
~~
.bp
.ju
.ce
.ul
COMMAND MODE `ICCommand Mode`IC
.sp
.sp
.ul
Command Mode Notation`TC~~~~~Command Mode Notation`TC `ICNotation`IC
.sp 2
.of 10
`IX$`IX~~~~~~~~~is a shorthand for "<ESC>". `IC<ESC> key`IC
Wherever "$" appears in a command mode example, press the <ESC> key.
.br
.of 10
<ESC>~~~~~is simply the <ESC> key which generates the control
character "escape". In rare cases where you have no <ESC> key, you can
customize any other control character to act as the <ESC> key.
`ICCommand escape character (See <ESC> key)`IC
.sp
.of 10
`IX<TAB>`IX~~~~~represents the TAB character - press the <TAB> key.
.br
.of 10
<CR>~~~~~~represents "carriage return", which is generated by pressing
the RETURN key.  Note that pressing RETURN usually generates two
control characters - "carriage return" and "line feed", represented as
"<CR>~<LF>".
.sp
.of 10
<CTRL-~>~~Control characters are produced by holding down the CTRL key
like a SHIFT key and typing the indicated letter as in "<CTRL-letter>".
`ICControl characters - typing`IC
.sp
.of 10
[~~~~]~~~~The bracket characters used for iteration loops
are printed as "[" and "]" in this manual.  You may be more
familiar with the angle brackets "<" and ">".  You can
choose which characters to use during customization. `IC[ and ]`IC `IC< and >`IC
`ICIteration brackets`IC
.sp 2
.ul
Command Lines `TC~~~~~Command Lines`TC
.sp
     In Command Mode you are prompted `ICCommand mode prompt`IC for
`IXcommand line`IXs by the "COMMAND:" prompt.  The first few command
prompts are preceded by a help message to remind you of the most used
commands. Each command line you enter consists  of a single command,
multiple commands or a special sequence of commands called an
"`IXiteration loop`IX".  Each command line is ended by typing RETURN
or the <ESC> key twice, at which time the command line is executed.
.sp
     Since no commands are executed until you type RETURN (or <ESC>
twice), the line may be edited `ICCommand line editing`IC with most
common line editing characters. They are described in detail below.
Once execution begins, it may often be aborted by typing <CTRL-C>.
This causes a `IX*BREAK*`IX and a new command prompt to be displayed.
VEDIT checks for the <CTRL-C> before any new command is executed,
when anything is displayed on the screen and during commands which
repeatedly access the disk.
.sp
     The <ESC> key is echoed with a "$", which is also used in the
examples in this manual to represent the <ESC> key. The RETURN or
<CR> key is echoed with a <CR>~<LF> pair, and the pair is also
entered into the command line. `IC<CR> and <LF>`IC `ICRETURN key`IC
.sp
`ICText strings (See Strings)`IC
     Commands such as "I", "F" and "S", which take "text string" `ICStrings (of text)`IC
arguments must end in the "text delimiter", typically <ESC>.  If you
type RETURN before the final delimiter, the command prompt changes to
"-" as a reminder. `ICDelimiters (text)`IC
.sp
Prompt:~"-"~~~~~This means VEDIT is waiting for the text delimiter.
`IC"-" prompt`IC
.sp
     If you have made a mistake, receive the "-" prompt and do not know
what the delimiter is, type <CTRL-C> to abort the command.
.sp
`ICMemory space - full`IC
     If, while typing, the command line should exhaust the amount of
memory space available to it, (the edit buffer, text registers and
command line all share the same memory space) VEDIT will send the
"Bell" character to the console and neither accept nor echo any more
characters. The user will have to edit the current command line in
order to end it and should then rectify the full memory situation.
Even when the memory is full, (see "U" command) up to ten characters
may be typed on the command line.
.sp
     Occasionally you may see a "`IX<<`IX" displayed at the end of a
line preceding the  command prompt.  This only indicates that the
previous line did not end in a carriage return-line feed.  It
typically occurs with the "-T" command.
.sp 2
.cp 7
.ul
Command Line Editing `TC~~~~~Command Line Editing`TC `ICCommand line editing`IC
.sp
     Several common control characters are recognized in command mode
as line editing characters. `ICControl characters - typing`IC They are:
.sp 2
.ta 25
.of 24
`IX<CTRL-H>`IX~or~<BACKSPACE>~Delete the last character typed and
echo a <CTRL-H> to the console. `ICBACKSPACE key`IC
.sp
.of 24
`IX<RUBOUT>`IX~or~<DELETE>~~~~Delete the last character typed and
echo the deleted character to the console. `ICRUBOUT key`IC `ICDELETE key`IC
.sp
.of 24
`IX<CTRL-R>`IX~~~~~~~~~~~~~~~~Does not change the command line, but echoes
the entire command line back to the console.
.sp
.of 24
`IX<CTRL-U>`IX~~~~~~~~~~~~~~~~Delete the entire command line and send
a "#" to the console.
.sp
.of 24
`IX<CTRL-X>`IX~~~~~~~~~~~~~~~~Identical to <CTRL-U>.
.sp 2
     If you wish to search for one of these characters in the
text, or use one within any other string, you must precede it with
a `IX<CTRL-Q>`IX.  `ICSearch (ing)`IC
<CTRL-Q> causes the following character to be taken
literally, and not be interpreted as a line editing character, a RETURN
or any other special character.
.sp 2
.cp 7
.ul
Controlling Console Display `TC~~~~~Controlling Console Display`TC
.sp
     Any screen output in Command Mode from commands such as "T",
"RT", "EL" and "ED" can be temporarily stopped for easier reading by
typing <CTRL-S>.  Typing any other key, but typically another
<CTRL-S>, will then resume the screen output.  You can also abort the
command by typing <CTRL-C>.
.sp
`ICStop character`IC
     The "RT" (type text register) command will also respond to
<CTRL-S> characters that are in the text, automatically stopping the
screen display when the <CTRL-S> "stop character" is encountered.  The
display will resume when the user types any key. This is useful in
macros when displaying several screens of text, such as a long menu.  Be
careful when printing files which contain <CTRL-S>, since it may have
an unexpected effect on the printer.
.sp 2
.cp 7
.ul
Help Command `TC~~~~~Help Command`TC `ICHelp (command)`IC
.sp
     VEDIT offers an interactive On-line help facility.  Separate help
is available in the Command and Visual Modes.  There are two types of
help available in Command Mode via the "H" and "EH" commands.  The "H"
command gives help with any particular command, such as a list of all
the edit switches or parameters.  The "EH" command is more oriented
toward help with common editing tasks.
.sp
     Both help commands are interactive - they first display several
screens of a help menu from which you pick the desired help topic.
Alternatively, to skip the menu, you can follow the "H" or "EH"
command by the topic code.  For example, for a list of all edit
switches give the command: `ICH`IC `ICEH`IC
.sp
.ti 10
HES~~~~~~~~~~~~List edit switches, skipping help menu.
.sp
     Technically, the "H" and "EH" commands and even the
Visual Mode [HELP] function operate identically, only the particular
help files used on disk are different.  The "H" command uses the file
"VHELP.HLP", "EH" uses "VEHELP.HLP" and [HELP] uses "VVHELP.HLP".
.sp
     The three help files are standard text files which may be edited
with VEDIT.  If you desire, you can change and expand the On-line help
to suit your purposes.  You can also very easily create On-line help
for a print formatter, such as V-PRINT, or for a compiler you are
using.  To do this just rename the file containing the help text to
"VEHELP.HLP".  It will then be accessible via the "EH" command. If you
want the help text displayed one screen at a time, you can embed the
<CTRL-S> "`IXstop character`IXs" in it at the appropriate places.
.sp
     All three help files are designed for screens 24 lines deep by 80
characters wide.  If your screen is smaller, you will have to edit the
help files.  This is described in the subsection "Modifying the Help
Files", along with descriptions of how to create a help file with
menus, sub-menus, etc.
.br
.bp
.ce
.ul
FILE OPERATIONS `TC~~~~~File Operations`TC
.ta 10 28
.sp 2
.ul
Exiting With Saving `TC~~~~~~~~~~Exiting With Saving`TC
.sp
     Usually when you are done editing a file you will want to save the
new file on disk and leave VEDIT.  This is done with the "`IXEX`IX"
command from Command Mode.  It does not matter where you are in the
file, or how large the file is, "EX" will save the file on disk and
leave VEDIT.
.sp
~~~~~Command:~~~EX~~~~~~Save file on disk and leave VEDIT.
.sp
     It is also possible to save the file on disk and `ulremain`ul in
VEDIT with the "`IXEY`IX" command.  The "EY" command is useful when you
are finished editing one file and want to edit another file.  An added
benefit is that the "EY" command does not alter the text registers.
.sp
~~~~~Command:~~~EY~~~~~~Save file on disk and remain in VEDIT.
.sp 2
.cp 7
.ul
Quitting Without Saving `TC~~~~~~~~~~Quitting Without Saving`TC
.sp
     VEDIT allows you to quit editing a file without saving the changes.
The "`IXEQ`IX" command will quit and return you to the operating system,
while the "`IXEZ`IX" command will leave you in VEDIT with no files active.
Both commands require confirmation of the decision to quit (this is to
ensure that you do not forget to save important changes).  You can skip
the confirmation prompt by including a "Y" in the quit command: "EQY" or
"EZY".  The text registers will retain their contents when using the
"EZ" or "EZY" command.
.sp 2
.cp 7
.ul
Save File and Continue Editing `TC~~~~~~~~~~Save File and Continue Editing`TC
.sp
      If you are spending a lot of time editing a file, it
is a good habit to routinely save the file on disk and then continue
editing it.  Otherwise, all of your edit changes could be lost should a
power or hardware failure occur.  This also protects you from your own
mistakes.  The command to save a file on disk and then continue editing
it is: `ICEA`IC
.sp
~~~~~Command:~~~EA~~~~~~Save file on disk and continue editing it.
.sp
     Following the "EA" command the edit pointer, or cursor in Visual
Mode, will be at its previous position.  The text marker positions
will also be maintained.  It is frequently easier to use the
`IX[RESTART]`IX function in Visual Mode rather than the "EA" command.
.sp
.of 7
Note:~~The "EA" command starts a new edit session.  Therefore, if an
"EA" is later followed by an "EQ", you will only ignore those changes
made after the "EA" command.  Those changes made before the "EA"
command will have already been saved on disk.
.sp 2
.cp 7
.ul
Editing a Second File `TC~~~~~~~~~~Editing a Second File`TC `ICEditing second file`IC
.sp
     When you are done editing `ICfile editing`IC one file and need to
edit another, it is not necessary to exit VEDIT and then re-invoke
VEDIT for the second file. `ICInvoking VEDIT`IC
The "`IXEY`IX" command
saves the file being edited on disk, in preparation for editing another
file.  It performs the equivalent of the "EX" command without
leaving VEDIT. The commands to finish editing one file and begin editing
another file (NEWFILE.TXT) are:
.sp
	EY `IXEB`IX newfile.txt
.sp
Notice that spaces may be added between commands and in front of a file
name to improve readability.
.sp 2
.ul
Directory Display `TC~~~~~~~~~~Directory Display`TC `ICDirectory display`IC
.sp
     The very convenient "`IXED`IX" command gives a display of the
disk directory.  Drive specifiers and the `IXwildcard characters`IX
"?" and "*" can also be used.  Some examples are:
.sp
	ED	gives the directory of the default drive.
.sp
	ED A:	gives the directory of drive "A".
.sp
	ED *.ASM	gives the directory of all ".ASM" files.
.sp
The "ED" command serves as a reminder of what files on a
disk have been or still need to be edited, merged split, etc.  In case
the disk becomes full `ICDisk full error (recovery)`IC
and VEDIT gives you a `IX"NO DISK SPACE"`IX
or `IX"NO DIR SPACE"`IX error, the "ED" command helps you delete any unneeded files on
the disk.  Files can be deleted with the "`IXEK`IX" command.
.sp
     Note that with CP/M, an optional user number may be specified
following any file name specified in VEDIT.  `ICCP/M User Number`IC
Therefore, the command to display the CP/M directory of drive "B", user
number "4" is:
.sp
.of 27
	ED B:=4	gives the directory of drive "B", user number "4".
.sp
.of 6
NOTE:~WHEN DELETING FILES, DO NOT DELETE ANY ".$$$" or
".$R$" FILES FROM WITHIN VEDIT!  THESE ARE THE TEMPORARY EDIT
FILES VEDIT IS USING.  DELETING THESE FILES WILL RESULT IN LOST TEXT.
THE VEDIT.COM OR VEDIT.CMD FILE CAN BE DELETED IF NECESSARY.
`ICDeleting files`IC `IC".$$$" file`IC `IC".$R$" file`IC
.sp
.cp 7
.ul
Extracting Portions of Other Files `TC~~~~~~~~~~Extracting Portions of Other Files`TC
`ICInserting files`IC
.sp
     It is possible to append another file to the end of file being
edited with the "ER" command, in effect merging the two files.  In many
instances, however, you will want to extract only a portion of another
file and insert it into the middle of the file being edited.  This
portion might be a paragraph, a single sentence or a program
subroutine.  This is done with the "EG" command.  The "EG" command
takes as arguments the file name and the line range to
be inserted.  Therefore, you will need to know the line numbers of the
text to be extracted.  This can be determined with the "EL" command:
`ICDisplaying files`IC
.sp
~~~~~~~~~Example:~EL MYFILE.TXT~~~~View MYFILE.TXT with line numbers.
.sp
Simply note the beginning and ending line numbers of the text to
extract.  Let's say the line numbers are 235 and 272 respectively.
Then the command to extract the text would be:
.sp
~~~~~~~~~Example:~EG MYFILE.TXT[235,272]
.sp
The text will be inserted at the edit position.
.sp
     If you do not want to view all the lines of a file you can issue
the "EL" command with a beginning and ending line number as in the "EG"
command.  For example: "EL~MYFILE.TXT[200,400]".
.sp
     The "EG" and "EL" commands allow a drive designator to be included.
With CP/M systems, a User number may also be specified.
.sp 2
.cp 7
.ta 10 28
.ul
Disk Buffering in Command Mode `TC~~~~~~~~~~Disk Buffering in Command Mode`TC
.sp
     While the disk buffering can be fully automatic in `ICAuto-buffering`IC
Visual Mode, it is not done automatically in Command Mode because it would
interfere with the explicit file handling often done in Command Mode.
VEDIT has a full set of commands for reading and writing files.
Commands must be issued in order to read a file, write a file and
perform forward disk buffering.  In some cases it will be easier to
switch into visual mode and allow it to perform the disk buffering
automatically.
.sp
     The "`IXER`IX" command opens a file for reading, but does not actually
read anything in.  The file can be read with the "nA" command.
Similarly, the "`IXEW`IX" command opens a file for writing, but does not
write anything out.  Text can be written out with the "nW" command.
`IXForward disk buffering`IX in Command Mode, therefore, can be done with successive
"W" and "A" commands.
.sp
     Some commands perform automatic reading/writing when invoked. The
"`IXEB`IX" command performs an `IXauto-read`IX which reads in the
entire file from disk or until the `IXedit buffer`IX is nearly full.
The "`IXEY`IX" command performs all the reading and writing to finish
editing and saving a file without leaving the editor.
.sp
`ICGlobal operations`IC
.br
     The commands which take the "global" modifier "_" will also perform
automatic disk buffering. `IC_`IC The command "_`IXB`IX" moves back to the
beginning of the file, performing `IXbackward disk buffering`IX as
needed.  The command "_`IXZ`IX" moves the end of the file, and the
command "_`IXL`IX" moves forward in the file, each performing
`IXforward disk buffering`IX as needed.  The "_T" (type) command will
also perform forward disk buffering when needed. The "`IXN`IX" command
(same as "_F") can perform forward disk buffering to find occurrences
of a string anywhere in the file.  These commands will perform
automatic disk buffering independent
of the setting of the "Auto Buffering in Visual Mode" switch.
.sp
     As described earlier, `IXbackward disk buffering`IX is
accomplished by writing text from the end of the edit buffer to the
temporary `IX".$R$" file`IX, and reading back text already written to
the `IXOutput file`IX.  VEDIT can perform this disk buffering
automatically in Visual Mode.  The "-W" and "-A" commands allow you to
do this manually in Command Mode.  Because of the complexity of these
commands, we suggest you not use them until you are thoroughly familiar
with all other aspects of VEDIT's file handling.  Generally, the easy
to use "_B", "_Z", "_L", "_T" and "_F" commands can perform any additional
disk buffering you will need in Command Mode.
.sp
     The "-n`IXA`IX" and "-0A" commands allow text which has already been
written to the Output file to be read back into the edit buffer.
"-nA" will read "n" lines back from the output file, or until the edit
buffer is full, or the output file is empty.  "-0A" will read lines
back until the edit buffer is `IX"nearly" full`IX or the output file is
empty.
.sp
     The "-n`IXW`IX" command will write text from the end of the
edit buffer out to the temporary .$R$ file.
Its only purpose is to make more memory space available for
performing the "-nA" command, or any other time you need more memory
space. `ICMemory space (saving)`IC
.sp
     Whenever an "`IXA`IX" command is issued or VEDIT performs auto disk
buffering, VEDIT will always read the contents of the `IX".$R$" file`IX
back into the edit buffer, before reading any more from the Input
file.  You, therefore, do not need to explicitly remember whether or
not there is any text in the ".$R$" file.
.sp 2
.cp 7
.ta 10 28
.ul
Disk Write Error Recovery `TC~~~~~~~~~~Disk Write Error Recovery`TC `IC Disk full error (recovery)`IC
`ICWrite errors (See Disk full error)`IC
.sp
     Since many systems run with floppy disks which have limited
storage capacity, the typical user will occasionally encounter a "Full
Disk" error condition. `ICFull disk (See Disk full error)`IC
This is caused by either running out of `IXdisk space`IX,
leading to the error message `IX"NO DISK SPACE"`IX, or running out of
directory space, leading to the error message `IX"NO DIR SPACE"`IX.
Fortunately, VEDIT allows you to recover from these errors using one
of two recovery procedures.  One is to delete files `ICDeleting files`IC
from the disk
using the "`IXEK`IX" command until enough space exists to write the rest of
file out.  The second is to use the "`IXEC`IX" command to allow removing the
full disk and inserting another disk on which to complete the
operation.  The following paragraphs describe these procedures in some
detail, and an example is given in the Tutorial.
.sp
     The best policy is to avoid "Full Disk" errors by making sure
that there is enough space before you begin editing.  If you are
editing files more than 1/3 disk in length, it is best to read the
Input file from one drive and write the Output file on another drive.
For example, if the Input file and VEDIT are on drive A and the disk
in drive B is blank, give the command: `ICMultiple files`IC `ICMultiple drives`IC
.sp
	VEDIT infile.ext b:outfile.ext
.sp
     The simplest and most common recovery is to delete files from the
disk which is full.  You can use the "`IXED`IX" command to display a
directory of the disk.  If you find files which you can delete, you
are all set.  You can then re-issue the command which led to the full
disk error.  Any `IX".BAK" file`IXs can usually be deleted.  You can also
consider deleting any files which you know are backed-up on other
disks.  Never delete the ".$$$" and ".$R$" files from within
VEDIT.  (You can delete them from the operating system, in the
unlikely event they appear on the directory there.)
.sp
     If you are still reading this in order to learn more about VEDIT,
STOP.  You are very unlikely to ever require the following procedures.
They are described here for completeness only.
.sp
     There may be times when you cannot delete enough files to finish
the `IXedit session`IX.  You then have several alternatives.  One is to
close the current output file (with the "`IXEF`IX" command) and create a
second output file on another drive.  An example is:
.sp
.nj
.nf
.ta 10 28
	EF	Close the current output file.
	EWA:PART2	Create an output file on another drive.
	EX	Exit the edit session.
.sp
.fi
.ju
You can then use VEDIT (or CP/M PIP or MS-DOS COPY) to merge the two partial
output files back into one file.  (See the Tutorial for merging files.)
.sp
     If all the disks in the drives are full, you will have to either
change disks using the "`IXEC`IX" command or delete the Input file.  In
either case you want to read as much of the Input file and hope that
there is enough room to read all of it.  Begin by issuing the command:
.sp
	#A
.sp
Then look at the end of the edit buffer to see if all of the file was
read in. If not, the recovery will be more complicated.  If all of the
Input file has been read, it is often simplest to delete this Input
file from disk with the "`IXEK`IX" command.  This will make enough space
available for the rest of the Output file.  If you delete the Input
file, there will be no ".BAK" backup file when you exit VEDIT.  For
example, if the file you are editing is "LETTER.TXT", you could give
the following commands: `IC".BAK" file`IC
.sp
.nj
.nf
	EKletter.txt	Delete the Input file.
	EX	End the edit session.
.ju
.fi
.sp
     Alternately, if you need to keep the original `IXInput file`IX, you can
use the "EC" command to change disks and write the second part of the
Output file to an empty disk.  First issue the "EF" command to close
the current Output file.  The "EC" command will allow you to insert
another (empty) disk into any drive.  Example commands are:
.sp
.nj
.nf
	EF	Close the current output file.
	EC	and type RETURN
	EWPART2	Create a second output file.
	EX	End the edit session.
.ju
.fi
.sp
You will then have to use VEDIT (or CP/M PIP or MS-DOS COPY) to merge your two
`IXOutput file`IXs back into one file.  This procedure has several potential
shortcomings.  If you were using backward disk buffering, you may get
the error message `IX"REV FILE OPEN"`IX, in which case you cannot
change any disks.  You will then have to make more space on the
existing disks by deleting files, possibly the Input file.
.sp
     If you were unable to read the entire Input file into the edit
buffer, the procedure becomes still more complicated.  (Try again to
make more space free on the existing disks!)  If you have a copy
of your Input file on a backup disk, delete the Input
file, which should free enough disk space to end the edit session.
All text which you just edited or entered will be in the Output file,
but the Output file will be missing the last portion of the Input file
which was never read in.  You must examine the Output file to see how
much is missing.  Then copy your backup of the original Input file to
a blank disk.  Edit this file by deleting the entire front portion up
to the text which is missing from the partial Output file.  Exit
VEDIT.  Then use VEDIT or PIP to merge the Output file and the unread
portion of the original Input file back together.  This is a
complicated procedure, but at least none of your edited text is lost.
.sp
     If in the previous paragraph you know that you do not have a
backup copy of the Input file, you will have to use the "EC" command
procedure to write a second Output file to a blank diskette.  However,
by using the "EC" command, VEDIT will not be able to continue reading
any unread portion of the Input file.  You will therefore have to merge the
Output file from the original disk with the second Output file, with
the unread portion of the Input file.
.sp
     If you cannot change disks because you were using backward disk
buffering, you will have to make more space free on the existing disks
by deleting files.  If you want to avoid the complexities of deleting
the Input file, you can delete any ".COM" or ".CMD" files, including
VEDIT, which you can probably restore from a backup disk.
.br
.bp
.ce
.ul
COMMAND MODE FEATURES `TC~~~~~Command Mode Features`TC
.sp 2
.ul
Command Modifiers (Search Options) `TC~~~~~~~~~~Command Modifiers`TC `ICSearch options`IC
.sp
     There are three command modifiers which may be used to modify the
operation of some commands in desirable ways. These command modifiers
are most commonly used with the search commands, but apply to other
commands as well.  The command modifiers are single characters which
precede the command and affect only that command.  A command can have
more than one modifier - it can even have all three.
.sp
     In some instances, especially when writing macros, you will want
to repeatedly use a modifier on all applicable commands.  Since it
would be tedious to have to include it each time, you can select to
have any (or all) of the modifiers included by default.  The modifier
then no longer has to be typed. Enabling the three modifiers by
default is controlled with three "ES" command switches. The initial
value of the command switches is set during customization, although we
suggest you customize them all to OFF.
.sp
.nj
.nf
.rm 75
.ta 20 53
.ul
Modifier	Meaning	Affected~Commands
.sp
_ (underscore)	Perform global file operation	B, F, L, S, T, Z
.br
@	Use explicit text delimiter	F, S, I, RI, YT
.br
:	Suppress error handling	F, L, S
.br
:	Suppress <CR>~<LF>	XT, YR, YW
.sp 2
.ju
.rm 70
.ul
Global File Operations `TC~~~~~~~~~~Global File Operations`TC `ICGlobal operations`IC
.sp
     The "_" (underscore) modifier is used to make commands "global"
to the entire file, performing automatic disk buffering when necessary.
The "_F" and "_S" commands will perform the search or replace to the
end of the file instead of just to the end of the edit buffer. "_B"
moves the edit pointer to the beginning of the file, while "_Z" moves
to the end of the file. You may want to think of the "_" modifier as a
command option which makes the size of files less noticeable.
.sp
     You can select to have the global modifier enabled by default
with the command switch:
.sp
.ti 9
ES~10~1~~~~~~Enable global modifier by default.
.sp
     See the section "Disk Buffering in Command Mode" for more
information about the global modifier.
.sp 2
.ul
`IXText Strings`IX and Explicit Delimiters `TC~~~~~~~~~~Text Strings and Explicit Delimiters`TC
.sp
     The commands "F", "S", "I", "RI" and "YT" are followed by a
string of characters called a "text string". `ICStrings (of text) - See Text Strings`IC
Since the text string can be of any length and contain any character,
including RETURN, there has to be some way of indicating the end of
the text string.  This is done with a special character called the
"text delimiter", which is normally the <ESC> character. `ICDelimiters (text)`IC
Optionally, you can use the "`IX@`IX" modifier to have an "explicit
delimiter" begin and end the text string. `ICExplicit Delimiter (See Delimiter)`IC
With this modifier, the character immediately following
the "F", "S", "I", RI" or "YT" command is the delimiter.  Any
character can be the delimiter, but "`IX/`IX" is a good choice.  Note
that the text string itself cannot contain the explicit delimiter.  In
the following examples, the commands on the left side are equivalent
to those on the right.
.sp
.ta 9 35
	Fspeled$V	@F/speled/V `ICF`IC
.sp
	Sspeled$spelled$V	@S/speled/spelled/V `ICS`IC
.sp
	4Fpoint$V	4@F:point:V
.sp
	Ia new line$$	@I/a new line/ `ICI`IC
.sp
     The explicit delimiter option can be made the default with the
command switch:
.sp
.ti 9
"`IXES`IX~9~1"
.sp
     Although using this option requires more characters to be typed,
many users find that it makes the commands more understandable.  It
eliminates the need for <ESC> to terminate any text strings and nearly
eliminates the need for <ESC> entirely.  It also allows the <ESC>
character to be searched. `ICSearch for <ESC>`IC `IC<ESC> key`IC For
example, the following command searches for the string "h<ESC><ESC>":
.sp
	@F/h<ESC><ESC>/
.sp
     Note that the <ESC>~<ESC> therefore does not end a command if it
appears before the explicit delimiter.  If you type <ESC>~<ESC> or RETURN
before the explicit delimiter, the command prompt changes to "-" to
remind you that VEDIT is still waiting for the delimiter.  For example,
to find "LABEL" at the beginning of a line, the search command would be:
.sp
.nj
.nf
.ta 10 35
	F<RETURN>
	LABEL<ESC><ESC>	Note: Prompt changes to "-" here.
.sp
`ICCommand mode prompt`IC
.fi
.ju
     The "-" command prompt is normal for strings which contain RETURN.
However, if you get a "-" by mistake, type <CTRL-C> to abort the command.
.sp
     The command "`IXF`IX$$" will always search for the last used string,
even if the explicit delimiter was used for the original string or is
currently in effect. `ICSearch (ing)`IC
.sp
.ti 8
F$$~~~~~~Search for last used string. (Must end in two <ESC>)
.sp 2
`ICSuppress error handling (See also Search errors)`IC
`ICIgnore search errors (See Suppress error handling)`IC
`ICSearch errors`IC
.ul
Suppress Error Handling `TC~~~~~~~~~~Suppress Error Handling`TC
.sp
     Normally, an error results if a search string is not found when
using the "F" or "S" commands.  An error also results if the "L"
command attempts to go past either end of the edit buffer (file).  The
error handling performs two functions.  First, it displays an error
message.  Second, it stops the execution of any executing commands.
Search errors resulting from the "F" and "S" commands and
the "L" command error can be suppressed with the "`IX:`IX" command
modifier.  (Note: other errors cannot be suppressed.)
.sp
     Search errors are often suppressed inside command macros.  For
example, a macro might contain a sequence of "S" (substitute) commands
where you do not want the macro to terminate if some of the search
strings are not found. Instead of using the ":" modifier, it is
usually easier to suppress search errors (and "L" command errors) with
the command:
.sp
.ti 9
ES~8~1~~~~~Suppress search and "L" command errors.
.sp
     When using the ":" modifier or "ES~8~1" command, search errors
are still detected, but are handled differently.  First, no error
message is given.  Second, command execution continues with any
commands following the current iteration loop.  If the command causing
the error is not within an iteration loop, or no commands follow the
iteration loop, then command execution stops.
.sp 2
.ul
Literal Character in Text Strings `TC~~~~~~~~~~Literal Character in Text Strings`TC
.sp
     The "`IXliteral character`IX" `IX<CTRL-Q>`IX operates similar to the
`IX[NEXT CHAR LITERAL]`IX in Visual Mode - the next character is
treated literally and not interpreted.  The literal character is only
meaningful inside of text strings.  This is the only way to search
for characters such as `IX<CTRL-R>`IX, `IX<CTRL-U>`IX and
`IX<CTRL-H>`IX which are also used for line editing.  It is also
an alternative way to search for the <ESC> character. `ICSearch for <ESC>`IC
In the following examples, one command inserts a CTRL-H> into the text and
the second command searches for a <CTRL-H> : `ICInserting text`IC
`ICinserting control characters`IC
.sp
	Iword<CTRL-Q><CTRL-H>$$~~~~~~~~Insert a <CTRL-H>.
.sp
	Fword<CTRL-Q><CTRL-H>$$~~~~~~~~Search for a <CTRL-H>.
.sp
`IC<CR> and <LF>`IC
.br
     MS-DOS, CP/M and VEDIT all require that lines end in a <CR>~<LF> pair.
However, when files are transferred from `IXmainframe computers`IX, the
lines often end in a <CR> without the <LF>.  These lone <CR> must be
changed to <CR>~<LF> pairs.  One cannot simply search for a <CR> by
typing the RETURN key because it is expanded into <CR>~<LF>, unless
the RETURN is preceded with a "<CTRL-Q>".  Therefore, the command to
change all lone <CR> to <CR>~<LF> pairs is:
.sp
	b#S<CTRL-Q><CR>$<CR>$$~~~~~~~~~Change <CR> to <CR><LF>.
.sp 2
.cp 6
.ul
Pattern Matching `TC~~~~~~~~~~Pattern Matching`TC `ICPattern matching`IC
.sp
`ICSearch (ing)`IC
     This is a fairly advanced topic which you should be aware
of, because of its potential usefulness and power.  However, you should wait
until you are familiar with VEDIT's basic search and replace operations
before attempting to understand the details.
.sp
     Often when performing a search operation, you want to search for a
type of character, instead of a particular character.  For example, you
may want to search for the next number or for the next word beginning
in a capital letter.  VEDIT allows for a wide variety of such
characters to be searched.  Such searches may be made from the Command
Mode or the Visual Mode.  These categories of characters are called
"patterns". Patterns can be searched with "Pattern
Matching Codes".  Each pattern matching code consists of a special
"lead-in" character followed by a mnemonic letter.  Normally the
lead-in character is "`IX|`IX".  If your keyboard does not have this,
it can be changed during customization. The mnemonic letter may
be entered in upper or lower case.  For purposes of clarity, all
examples will show these letters in upper case.
.sp
`ICSeparator (pattern)`IC
.br
     A commonly used search "pattern" is the "separator". A separator
is any character which is not a letter or a numeric digit.  For
example, a simple search for the word "and" would result in matches by
"sand", "Andres" and others.  A search for "~and~" would be better,
but would fail if the "and" appeared at the beginning or end of a
line. The pattern match code for a separator is "|S". The |S" will
match a space, a tab, a RETURN or any other character which is not a
letter or a digit.  Therefore, the best search string for the word
"and" is:
.sp
String:~~~|Sand|S~~~~~~~~~~~~~~Best search string for the word "and".
.sp
     Another commonly used pattern is "|X" which will match any character.  There
are many other patterns possible in VEDIT. The pattern matching codes
are:
.sp
`ICPattern matching`IC
.cp 20
|A~~Matches any alphabetic letter, upper or lower case.
.br
|B~~Matches a blank - a single space or a tab.
.br
.of 4
|C~~Matches any control character - a character with a value of 0 -
31 (decimal).
.br
|D~~Matches any numeric digit - "0" through "9".
.br
|F~~Matches any alphanumeric character - a letter or a digit.
.br
.of 4
|L~~Matches any line terminator - Line Feed, Form Feed or End
Of File.  Also matches the <CR>~<LF> pair.
.br
.of 4
|M~~Matches multiple characters - zero, one or more characters so that
the string following the "|M" is satisfied.
.br
.of 4
|N~~Matches any character which is NOT the following single character
or pattern matching code.
.br
|S~~Matches any separator - a character which is not a letter or digit.
.br
|U~~Matches any upper case letter.
.br
|V~~Matches any lower case letter.
.br
|W~~Matches "white space" - one or multiple spaces and/or tabs.
.br
|X~~Matches any single character.
.br
.br
.of 4
||~~Matches a "|" - this is the literal "|".  Actually, any undefined
pattern matching code, will match a literal "|".
.sp 2
.cp 3
     The |M and |N require a little explaining.  The |N is a negation,
similar to our usage of "Not". The string "|Na" (think of it as not
"a") therefore matches any character except "a".  The command:
.sp
.ta 10
	Fexam|Ns$$~~~~~~~~~("$" designates the <ESC> key)
.sp
would find occurrences of "exam", "examiner", but not "exams".
.sp
     The code "|M" is useful for finding patterns where the beginning
and end are defined, but the middle does not matter.  The string
"|Sa|Mtion|S" matches words beginning in "a" and ending in "tion".
Besides being useful in searches, the "|M" code can be used to delete
large blocks of text.  For example, the following command would delete
this paragraph:
.sp
          @S/     The code|Mparagraph://~~~~~~~~End with a RETURN.
.sp
This "S" command is using "explicit delimiters", i.e. the "/"
characters.  This allows the command to end in a RETURN instead of two
<ESC>.  The double "//" at the command end means that the text which is
found will be replaced by nothing, i.e. deleted.
.sp
     In `IXassembly language`IX programming, any text following a
"`IX;`IX"
character is considered a comment.  Instructions are often followed by
a few tabs (to align the comments), the ";" and the comment.
The following command will delete the tabs (and/or spaces) and the
comment which follows any instruction.  Lines which are entirely
comments are left unchanged. `ICStrip comments`IC
`ICComments (Assembly language)`IC
.sp
         #@S/|W;|M<RETURN>
.br
         /<RETURN>
.br
         /~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~This command strips comments.
.sp 2
.cp 5
.ul
Edit Parameters and Switches `TC~~~~~~~~~~Edit Parameters and Switches`TC
`ICParameters - setting`IC
.sp
     The numerous parameters and switches controlled with the "EP" and
"ES" commands give you tremendous flexibility in using VEDIT.  If you
type just "EP" or "ES" with no arguments, you will see a display of
all the the current parameter or switch settings.
.sp
.ti 9
EP~~~~~~~~~Display the current values of all parameters.
.sp
     If you forget the parameter or switch numbers, use the On-line
Help to see a list of all the parameters or switches.
.sp
.ti 9
HES~~~~~~~~Display On-Line Help for "ES" command.
.sp
     The initial values for the "EP" parameters and "ES" switches can
be changed with the customization program.  You may want to do this if
you find yourself always changing a particular parameter or switch.
.sp 2
.cp 5
.ul
Printing Text `TC~~~~~~~~~~Printing Text`TC `ICPrinting text`IC
.sp
     Text can be printed from Command Mode with the "`IXEO`IX"
command.  This command takes a numeric argument similar to the "T"
command to specify how many lines before or after the edit pointer
are to be printed.  For example, "40EO" will print the following 40
lines, while "-5EO" will print the preceding 5 lines.  Additionally,
the command "0EO" will print all lines from the beginning of the edit
buffer to the current edit pointer. (The edit pointer is the same as
the cursor position when you change from Visual to Command Mode).
Therefore, the command to print the entire text is:
.sp
	B#EO~~~~~~~Print entire text on line printer.
.sp 2
.cp 7
.ul
WordStar (TM) Files `ICWordStar files`IC `TC~~~~~~~~~~WordStar (TM) Files`TC
.sp
`ICBit 8 characters`IC
     WordStar (tm) files and files from other word processors often
contain characters which have their High or 8th bit set.  These are
often difficult to edit with VEDIT and will often be displayed with
reverse video characters. Such files can be converted to normal text
files by using the "YS" command which "strips" the 8th bit.  Its syntax
is "mYS", where 'm' specifies the line range, as in the "T", "K" and
"L" commands.  "10YS" strips the High bit in all characters in the next
10 lines. `ICStrip high bit (See Bit 8 characters)`IC
.sp
.of 18
Command:~~B#YS~~~~Strips 8th bit of all characters in the edit buffer.
.sp
     If the paragraphs from the word processor are justified, you will
find them easier to edit if you first have VEDIT "unjustify" them to
remove the extra spaces between words.  This is described under
"Justification" in the Visual Mode section.
.sp 2
.cp 12
.ul
Text Registers `TC~~~~~~~~~~Text Registers`TC `ICText registers`IC
.sp
     The text registers have additional flexibility in Command
Mode.  Lines of text may be copied to a register with the
"`IXP`IX" command:
.sp
.ta 9 32
	35P5	Copy the next 35 lines to register 5.
.sp
	-6P+4	Append previous 6 lines to register 4. `ICAppend to text register`IC
.sp
	0P2	Empty out register 2.
.sp
     The "`IXG`IX" command inserts the contents of the specified register at the
edit pointer:
.sp
	G2	Insert register 2 at edit pointer.
.sp
     The "`IXRS`IX" command saves the contents of the specified register
in a disk file.  Various portions of a file or files may therefore be
appended to a text register, which is then saved as a new disk file.
`ICSave text on disk`IC
`ICSave text register`IC
.sp
.cp 2
.ta 9 32
.of 31
~~~~~~~~RS4~b:filesave.reg~~~~~Save contents of register 4 in
"filesave.reg" on drive "B".
.sp
     The "`IXRL`IX" command loads a register from a disk file.
This is often used to load command macros from disk.
`ICLoading text registers`IC
.sp
.cp 2
.of 31
~~~~~~~~RL4~b:filesave.reg~~~~~Load register 4 from
"filesave.reg" on drive "B".
.sp
     The contents of a text register can be displayed on the console with the
"`IXRT`IX" command:
.sp
	RT9	Type out contents of register 9.
.sp
`ICControl characters - in text`IC
     The "RT" command expands control characters, displays <ESC>
as a "$" and pauses when a <CTRL-S> is encountered.  Since this is
not suitable for initializing a terminal (`IXprogrammable function keys`IX,
etc.), the "`IXRD`IX" command is provided, which does not
expand control characters: `ICInitializing terminals`IC
.sp
	RD9	Dump out contents of register 9.
.sp
`ICPrinting text`IC
`ICPrinting text registers`IC
.br
     The "`IXRP`IX" command prints the contents of a text register.
This is useful for examining the contents of a text register.  It also
allows a disk file to be printed after first loading it into a text
register.
.sp
     The "`IXRU`IX" command displays the number of characters
contained in each of the text registers.  The sum of these ten values
is the last number displayed by the "`IXU`IX" command.  When any of
the text registers contain text, the status line message "TEXT"
appears in Visual Mode. `IC"TEXT" message`IC
.br
.bp
.ce
.ul
ITERATION LOOPS `TC~~~~~Iteration Loops`TC `ICIteration loop`IC
.sp 2
'ICCommand repeating (See Iteration loop)`IC
`ICRepeated commands (See Iteration loop)`IC
.ta 5 10 20
     An iteration loop is a group of commands which will be repeated
with or without user intervention as many times as desired.  As its
name implies, an iteration loop allows you to loop through a sequence
of commands over and over again.
.sp
`IC[ and ]`IC
.br
     An iteration loop's general construction is a group of commands
enclosed by brackets "[" and "]" and preceded by an `IXiteration
count`IX, which specifies how many times the entire group of commands
is to be executed. An iteration loop operates by executing the first
command of the group through the last command, and then starting over
again with the first command.
.sp
     The following example changes the first three occurrences
(if found) of "teeths" to "~teeth".
.sp
	Example:	3[Steeths$teeth$] `ICS`IC
.sp
     The above example is only illustrative since a single "S" command
would not normally be made into an iteration loop.  The "S" can itself
be preceded by an iteration count.  This also has the advantage of
executing much faster. Therefore, the preferred, faster (and simpler)
command for the above substitution is:
.sp
	Faster:	3Steeths$teeth$$
.sp
     Note that this is not an iteration loop, but rather just a form
of the "S" command.
.sp
     Commands such as "I" (insert) which do not take an iteration count
are often used singly in iteration loops.  For example, the command
to insert the text "~enter me three times" is:
.sp
	Example:	3[I enter me three times$]
.sp
`IC<ESC> key`IC
.br
     It is very important to observe the placement of any necessary
<ESC> to terminate strings and file names in iteration loops.  File
names must always be followed by an <ESC> and all text strings must
end with an <ESC> unless you are using explicit delimiters.  The
following example shows a common error in which the string "enter me
three times]" is entered into the text, which is not the intention.
.sp
	Wrong:	3[I enter me three times]
.sp
	Right:	3[I enter me three times$]
.sp 2
     If desired, each command may be ended with one <ESC>, in which
case you will not have to remember whether the command must end in
an <ESC> or not.
.sp
     The "[" and "]" may also occur within each other for more
complicated "nested" iteration loops. For example, the iteration
"5[4T]" displays the same four lines over and over again five times.
The iteration "3[~5[4T]~4L]" will display the same four lines five
times, then move to the next four lines and display them five times
and last, move to the next four lines and display them five times.
See "Numerical Capability" for more practical examples of iteration
loops.
.sp 2
.cp 5
.ul
Iteration Counts `TC~~~~~~~~~~Iteration Counts`TC  `ICIteration count`IC
.sp
     If no explicit iteration count is given, it defaults to "`IX#`IX"
(32767) which signifies "forever" or "all". `IC"Forever" (or "all")`IC
This is used when the iteration is to continue as long as possible.
"#" represents the maximum positive number 32767.  For clarity sake,
the "#" may also be explicitly specified. The following (illustrative)
example changes all occurrences of "teeths" to "teeth".
.sp
	Example:	#[Steeths$teeth$]
.sp
	Or:		[Steeths$teeth$]
.sp
`ICSearch errors`IC
`IC"CANNOT FIND"`IC
.br
     It is normal to get the error message "CANNOT~FIND~..." with an
iteration loop which searches for all occurrences of a string, because
it is literally searching for 32767 occurrences. (Note that the
commands "#F" and "#S" do not cause an error if at least one
occurrence is found.)  Therefore, an iteration loop ends when its
iteration count is exhausted or a search or other error occurs.
.sp 2
.ul
Commands Within Iteration Loops `TC~~~~~~~~~~Commands Within Iteration Loops`TC
.sp
     The commands "`IXI`IX" (Insert text) and "`IXT`IX" (Type text)
are useful in iteration loops. The "T" can be used to type out the
lines that are changed in an iteration loop without going into
`IXVisual Mode`IX. For example, the command to change all occurrences
of "teeths" to "teeth" and display those lines which changed is:
.sp
		[Steeths$teeth$0TT]
.sp
`ICInserting text`IC
.br
     The "I" command is useful when the same text is to be inserted
into the edit buffer many times. For example, to begin creating a
table of 60 lines, where each line begins with a <TAB> and ".....", the
following command can be used before the rest of the table is
filled in Visual Mode:
.sp
		60[I<TAB>.....<RETURN>$]
.sp
Note: The <RETURN> will be expanded into a <CR>~<LF> pair.
.sp
.bm -1
     Iteration loops begin operation from the current `IXedit pointer`IX
position.  Therefore, be sure to place the edit pointer
correctly before executing an iteration loop.
.sp
.bm +1
     An `IXiteration loop`IX will continue until its `IXiteration
count`IX is exhausted or until an error occurs.  A common error is an
unsuccessful search operation ("F" or "S" command) and many iterations
will normally stop with an unsuccessful search error message.
`ICSearch errors`IC
`ICSearch and Replace`IC
Search error handling is often suppressed in command macros. In this
situation, when a search is unsuccessful, no error is given, but the
iteration loop is stopped, and execution continues with the commands
following the iteration loop.  This may be an outer level iteration
loop.
.sp
     A similar situation occurs when using the "`IXL`IX" command
in iteration loops.  If the "L" command attempts to go past either end
of the edit buffer, it too will cause an error.  If error handling
is suppressed, the iteration is stopped, and execution continues with
the commands following the iteration.  This is convenient for any
iteration which needs to stop when the end of the text is reached.
The supplied print macro "PRINT.EXC" is such an example.
.sp 2
.ul
Using `IXVisual Mode`IX in `IXIteration Loop`IXs
`TC~~~~~~~~~~Using Visual Mode in Iteration Loops`TC
.sp
     `IXSearch and replace`IX operations are often used in conjunction
with the Visual Mode in order to edit the region, or to confirm that
the replacement was done correctly.  For example, the following command
will search for all occurrences of the word "temporary" and let those
regions of the text be edited in Visual Mode.
.sp
		[Ftemporary$V]
.sp
     The following command could be used with a form letter to change
"-name-" to the desired name, check that it was done correctly in
Visual Mode, and if necessary make any additional changes.
.sp
		[S-name-$Mr.~Jones$V]
.sp
     The Visual Mode has two ways of exiting back to Command Mode in
order to help in using iteration loops. The `IX[VISUAL EXIT]`IX simply
exits and lets any command iteration continue. The second,
`IX[VISUAL ESCAPE]`IX exits to Command Mode, but also aborts any iteration loop.
The latter is used when the user realizes that the iteration loop is
not doing what was intended and does not want to further
foul things up.  For example, in order to change all occurrences of
the word "and" to "or", the following command may have been given:
.sp
	Wrong:~~~~~[Sand$or$v]
.sp
The user might then see in Visual Mode that the word "sand" was
changed to "sor", which was not the intention.  The [VISUAL ESCAPE]
would stop the command and the following correct command could then
be given:
.sp
	Right:~~~~~[S and$ or$V]
.bp
.ul
.ce
COMMAND MACROS `TC~~~~~Command Macros`TC
.sp 2
.ta 10 20 30
     The following pages describe the process of grouping commands
together into text oriented "programs" called "Command Macros".  It assumes that the
reader is familiar with the individual commands of VEDIT.  You should
not feel compelled to understand this section until you are familiar
with all other aspects of VEDIT.
.sp
     The following pages also describe several additional commands in
VEDIT.  While these commands could be used by themselves, they are
primarily intended for use in command macros and are therefore
described in this context.
.sp 2
.ul
Command Macros `ICCommand macro`IC
.sp
     The text registers may hold commands which can be executed
just as if they had been typed in by hand.  Frequently used
commands, particularly long `IXiteration loop`IXs, can be saved in
the text registers.  Any sequence of commands executed in a text
register are referred to as "command
macros" or just "macros" for short.  `ICMacros (See Command macro)`IC
The macros are usually created and
edited in Visual Mode and are then moved to the appropriate register.  The
macros can also be saved on disk and be retrieved from disk (see RL
and RS commands).  Macros offer so many capabilities that it is
impossible to cover all of the possibilities.
.sp
     A macro is invoked with the "`IXM`IX" command:
.sp
	M6	Executes macro in register 6.
.sp
A macro may itself contain an "M" command to invoke a macro in another
register.  This can be done to a depth of five.
.sp
     A common use of macros is for large `IXsearch and replace`IX
operations.  Consider the example of a long manuscript split into
20 files in which 40 words were consistently misspelled.
The task of correcting the words in all 20 files can be done with 2
macros.  One will contain the search and replace for the 40 words.  The
second will edit each file, and for each file execute the
search/replace macro.  The first macro would appear as:
.sp
.nj
.nf
.cp 7
	ES 8 1
	ES 9 1
	b#s/word1/fix1/
	b#s/word2/fix2/
	b#s/word3/fix3/
	 .......
	b#s/word40/fix40/
.sp
.fi
.ju
The first two commands specify that explicit delimiters are to be
used and that search errors are to be suppressed.  Since explicit
delimiters are used, the <ESC> character is not needed anywhere.  `IC<ESC> key`IC
Macros do not need to end in <ESC>~<ESC>.  Search errors must be
suppressed, because otherwise, if any word is not found the entire
macro will abort.
.sp
     The second macro reads in each of the 20 files, executes the
first macro, writes the file back to disk, and continues with the next
file.  It is assumed that the first macro is in register 1.
.sp
.nj
.nf
.cp 10
	`IXEB`IX file1.txt
	`IXM`IX1
	`IXEY`IX
	EB file2.txt
	M1
	EY
	 ........
	EB file20.txt
	M1
	EY
.sp
.fi
.ju
Assuming that this macro is in register 0, the following command would
invoke the macro to perform the search and replace on all files:
.sp
	M0
.sp 2
     It is often desirable to save such complex macros on disk for
future use.  The commands to save these two macros are:
`ICSave text register`IC
.sp
.nj
.nf
	`IXRS`IX1 macro1.exc
	RS0 macro2.exc
.sp
.fi
.ju
Similarly, the commands to retrieve them from disk are:
`ICLoading text registers`IC
.sp
.nj
.nf
	`IXRL`IX1 macro1.exc
	RL0 macro2.exc
.sp
.fi
.ju
The commands to display them on the console are:
.sp
	`IXRT`IX1
	RT0
.sp 2
     Macros are most easily created in Visual Mode and then moved to
the appropriate text register.  They can be edited by appending the
text register to the end of the current edit buffer in Visual Mode,
making the changes and moving them back to the register.
`ICAppend to edit buffer`IC
.sp
     When command macros execute, the contents of a text register are
being used.  If the macro attempts to change the contents of its own
text register or of a register which invoked the macro, unpredictable
results could occur.  VEDIT checks for this possibility and if it
occurs gives the error message: `IX"MACRO ERROR"`IX.  It indicates that you
probably made a mistake in using command macros.
.sp 2
.cp 7
.ul
Additional Command Macro Features `TC~~~~~~~~~~Additional Command Macro Features`TC
.sp
`ICLoading text registers`IC
.br
     The "`IXRI`IX" command allows text to be loaded directly into a
register. `ICInserting text`IC The syntax is "RIrtext", where "r" is
the register number, and is otherwise identical to the "I" command.
The form "RI+rtext" will append "text" onto any text which is already
in register "r".
.sp
     The "RI" command could be used to manually insert text into a text
register, although it is generally easier to move the text in from
Visual Mode.  The main purpose for the "RI" command is for a command
macro to insert text, usually another macro, into a text register.  For
example, instead of setting up eight registers from eight disk files,
it may be easier to just load one disk file and then setup the eight
registers with eight "RI" commands.
.sp 2
     The "`IXR*`IX" command allows comment lines to be placed in command
macros.  All text following "R*" through the RETURN is ignored.
`ICComments in macros`IC
.sp
.ti 9
R*~~This demonstrates a comment inside a command macro.
.sp 2
     The "`IXYT`IX" command types a text string on the console.  Its
syntax is "YTtext" - the same as the "I" command. `ICTyping out text`IC
The "YT" command can be used to display progress messages or
debugging messages during the execution of command macros.
.sp
~~~~~Example:~~@YT/Part 1 is done/~~~~~Display a message on console.
.sp 2
`ICFormatting paragraphs`IC
.br
     The "`IXYF`IX" command will format a paragraph of text and is
analogous to the Visual Mode `IX[FORMAT PARAGRAPH]`IX function.  The
syntax is "nYF", where 'n' is optional and is the column number to be
used for the left margin of the paragraph.  If 'n' is left off, the
current `IXindent position`IX set in Visual Mode will be used to format the
paragraph.  The right margin used is the same as the word wrap column
set by the command parameter "EP~7".  If word wrap is off, the "YF"
command will be ignored.
.sp
.ti 9
YF~~~~~Format the paragraph the edit pointer is in.
.sp
     Following the "YF" command, the edit pointer will be positioned
at the beginning of the next paragraph.  The paragraph can also be
justified by enabling this option with the command switch "ES~11~1".
.sp 2
.ul
Display Input / Output File Names `TC~~~~~~~~~~Display Input / Output File Names`TC
.sp
.bm -1
     The input and output file names can be displayed on the console.
"`IXYR`IX" types the input (read) file name `ICInput file`IC
and "`IXYW`IX" types the output (write) file name `ICOutput file`IC
on the console. `ICFile name`IC The carriage
return following the file name may be suppressed by preceding the
command with a ":". `ICSuppressing <CR>`IC
The file names will commonly be re-routed to the
printer or edit buffer in conjunction with the "YP" and "YI" commands.
.sp
.bm +1
~~~~~~~~~~YW~~~~~Display output file name and a carriage return.
.sp
~~~~~~~~~:YW~~~~~Display output file name without carriage return.
.sp 2
.cp 8
.ul
Re-routing Console Output `TC~~~~~~~~~~Re-routing Console Output`TC `ICRe-routing console output`IC
.sp
     Any Command Mode console output, which normally goes to the
screen, can be re-routed to either the printer or the edit
buffer.  Such re-routing is in effect until the next Command Mode
prompt or until re-routing is canceled.
.sp
     The command "`IXYP`IX" will re-route console output to the
printer.  It is used in print formatting macros such as our supplied
PRINT.EXC.  The form "0YP" will stop the re-routing and allow normal
console output.  Note that the print command "`IXEO`IX" should not be
used in conjunction with "YP" (use "T" instead"), because all output
following the EO will go back to the console (i.e., "EO" stops the
re-routing). `ICPrinting text`IC
.sp
~~~~~Example:~~YP ED B:~~~~~~~~~~~~Print the directory of drive B.
.sp
     The "YP" command can be used in conjunction with the "YT" command
to send page headers, carriage returns and `IXform feed`IXs to the
printer.  For example, the commands to send a form-feed character
"<CTRL-L>" to the printer to start a new page is:
.sp
~~~~~Example:~~YP @YT/<CTRL-L>/~~~~Start a new page on printer.
.sp
.ce
`OSNOTE`OS
.sp
.ce
In earlier versions of VEDIT, "YP" was called "YL".
.sp 2
     "`IXYI`IX" re-routes console output to the edit buffer.  Each character
will be inserted at the edit pointer, and the edit pointer incremented.
The form "0YI" stops the re-routing. A simple example to try is:
.sp
~~~~~Example:~~YI~EV
.sp
This inserts the VEDIT version number into the edit buffer.  A more
elaborate example is given below under numerical capabilities.
Inserting text at the end of the edit buffer with the "YI" command will
proceed very quickly.  However, inserting text at the beginning of a
large file may take on the order of 1/2 second per character.
.sp
     The command "YI~-ED*.ASM" will insert all file names in the disk
directory, with a file extension of "ASM" into the edit buffer, one
file name per line. It is therefore possible for a command macro to
determine what files are on disk and automatically edit those files.
.sp 2
.cp 7
.ul
Numerical Capability `TC~~~~~~~~~~Numerical Capability`TC
.sp
     VEDIT has some limited numerical capability through the use of ten
"numeric registers".  They are accessed with the "`IXXS`IX", "`IXXA`IX"
and "`IXXT`IX" commands.  The main purpose for these registers is
counting.
.sp
~~~~~nXSr~~~~~sets numeric register "r" to the value "n".
.sp
~~~~~nXAr~~~~~adds the positive or negative value "n" to register "r".
.sp
.of 14
~~~~~XTr~~~~~~types the value of register "r" in decimal, followed by
a carriage return.  The command form ":XTr" suppresses the carriage
return. `ICSuppressing <CR>`IC
.sp
     A numeric register is used in the Print Formatter macro
"PRINT.EXC" to count page numbers.  A register could also be used to
count line numbers.  For example, the following command inserts 200
lines of the form "This is line number nnnn", where 'nnnn' increments for
each line: `ICLine numbers`IC
.sp
~~~~~Example:~~~~~YI 1XS1 200[@I/This is line number / XT1 1XA1 ]
.sp 2
`ICWord count`IC
.br
     The following command sequence uses the numeric capability to
count the number of words in a file and display the result.    This is
handy for any author who needs to know the number of words in a
manuscript.
.sp
.nf
.nj
         0XS1                        First zero out register 1.
         B [_@F/|S|A/ XA1]           Count words in entire file.
         XT1                         Type out the count.
.sp 2
.ju
`ICLine numbering`IC
.br
     Some applications, such as BASIC programming, require line
numbers at the beginning of each text line.  It is usually easier to
edit a file without line numbers, and when done editing, add the line
numbers to the beginning of each line.  The following command macro
adds line numbers starting with "100" and with an increment of
"10".  Of course, you could choose any other starting number and
increment.  (Note: the following command lines must be entered into a
text register and executed as a command macro.)
.sp
.nj
         100XS1                      Set the starting line number.
         B YI :XT1 @I/  /            Insert line number for first line.
         [                           Start an iteration loop.
         10XA1                       Add the increment.
         :@F/<RETURN>                Find beginning of next line.
         / :XT1 @I/  /               Insert line number for this line.
         ]                           End of iteration loop.
         -YI                         Stop inserting into text.
.ju
.bp
.cp 6
.ul
Command Macros In Visual Mode  `TC~~~~~~~~~~Command Macros In Visual Mode`TC
`ICCommand macro`IC
.sp
     The macro facility allows you to create your own edit functions
which are accessible via the `IX[MACRO]`IX key.  The fundamentals of
executing command macros from Visual Mode were described in the
previous section.  The Tutorial also contains an illustrative example.
.sp
     The following practical example is an edit function which
duplicates the current text line on the next line.  It also moves the
cursor to the beginning of the new line.  This saves you the time of
typing a line of text which is identical or nearly identical to the
previous line.
.sp
~~~~~Example:~~0L 1P9 L G9 -L~~~~~~~Macro to duplicate a line of text.
.sp 2
.cp 5
     The second example is a cursor movement function which moves the
cursor to the beginning of the next sentence.
.sp
~~~~~Example:~~@F/.|S/ @F/|F/ -C~~~~Macro to move cursor to beginning
.br
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~of next sentence.
.sp 2
     To use a macro as an edit function you must first have the
commands in a text register you will not be using for other
purposes.  Notice that the first macro uses text register 9 for its
operation; therefore, register 9 must be left empty.  In Visual Mode
you then press the [MACRO] key followed by the digit "0"~-~"9"
corresponding to the register to execute.
.sp
     If you will repeatedly be using a command macro (from Visual or
Command mode), it is easy to automatically set it up using the
VEDIT.INI auto-startup file.  For example, to set up the above two
macros, create a VEDIT.INI file with the following commands
in it (or add these commands to your existing VEDIT.INI file):
.sp
.nj
         @RI8;0L 1P9 L G9 -L;
         @RI7;@F/.|S/ @F/|F/ -C;
.sp
.ju
     Then after invoking VEDIT you can immediately use the two macros
from Visual Mode:
.sp
.ti 9
[MACRO] 8~~~~~~~~~~~~To duplicate a line.
.sp
.ti 9
[MACRO] 7~~~~~~~~~~~~To move cursor to next sentence.
.ju
.bp
.bm 4
.ce
.ul
Print Formatter Command Macroq`TC~~~~~Print Formatter Command Macro`TC `ICPrint formatter`IC
.sp 2
`ICPrinting text`IC
.br
     Your distribution disk contains a command macro `IXPRINT.EXC`IX, which
performs simple print formatting.  This macro can be used as an
alternative to the "`IXEO`IX" print command, which performs no formatting.
PRINT.EXC will skip over page perforations and print the file name and
page number at the top of each page.  A form feed is issued after the
text is printed. Much more sophisticated formatters can be written
with VEDIT macros; PRINT.EXC is intended as a macro example which is
relatively easy to understand and expand.  Possible enhancements
include line numbering, header and footer messages and more.
.sp
     To get ready to use PRINT.EXC issue the command:
.sp
         RL9~PRINT.EXC~~~~~~This loads the print formatter into VEDIT.
.sp
This loads the command macro into text register 9 where it will remain
unless you insert other text into the register.
.sp
     To print your text, simply issue the command:
.sp
         M9~~~~~~~~~~~~~~~~~This prints the entire edit buffer.
.sp
The entire edit buffer should begin printing.  You can stop the
printing by typing <CTRL-C>.
.sp
     Feel free to modify the print macro to suit your needs.  Modifying
this macro is also an informative way to learn more about VEDIT macros.
If you find that you use PRINT.EXC a lot, you can automatically load
it into VEDIT by placing the command "RL9 PRINT.EXC" into the VEDIT.INI
file, which is executed each time VEDIT is invoked.
.sp 1
     We hope that the simple PRINT.EXC macro inspires you to write
your own more sophisticated macros.  The Command Mode is a capable text
oriented programming language and the examples in this manual barely
scratch the surface of the applications which are possible.  The other
macro on your disk, ZIL-INT.EXC, is an example of a large brute force
search and replace macro, which can perform a translation, in this
case from ZILOG Z80 to INTEL style Z80 instructions.
.br
.bp
.ce
.ul
Modifying On-Line Help Files `TC~~~~~Modifying On-Line Help Files`TC
`ICOn-line help (command)`IC
.sp 2
     The three On-line help files used by VEDIT are all standard
text files and are easily changed and even expanded by the user.
Once you are comfortable with VEDIT we suggest that you experiment
with the help files and alter them to better serve your particular
needs.  Since two help commands are available in Command Mode, you may
even want to let one command give you On-line help for some other
program, such as the V-PRINT print formatter or the programming
compiler you are using.  It is very easy to even create a custom help
file from scratch.
.sp
     The simplest type of modification is changing the keyboard layout
displayed by the [HELP] function.  You will need to do this if
you are not using the preconfigured keyboard layout for the IBM PC
version, or the "Default Keyboard Layout" for all other versions.  To
change the displayed keyboard layout, edit the file "VVHELP.HLP".  The
keyboard layout appears at the very beginning of the file, exactly as
it appears on the screen.  Simply edit the control sequences shown
after each edit function until they correspond with your customized
keyboard layout.  When done, exit VEDIT and the new help file is saved.
.sp
     If you are a new VEDIT user, you may want to skip the rest of
this technical section until later.
.sp
     For this discussion we will assume that you are examining the
file "VHELP.HLP" in Visual Mode.  (If you print the file, you will not be
able to see the control characters in it.) The following complex
sounding discussion is much easier to understand if you are actually
viewing the help files and are familiar with the operation of the
On-line help.
.sp
     All three supplied help files have an identical structure, just
their content is different. Each help file begins with one screen full
of straight text.  The last line on the screen is a prompt to the
user.  Notice that it is followed by a <CTRL-S> (displayed as "^S" in
Visual Mode).  The <CTRL-S> serves two purposes.  First, it stops the
screen display at this point. Second, it allows the user to enter a
response on the keyboard.  If the response is just RETURN, the
following text in the help file up to the next <CTRL-S> is displayed.
If the user enters a text "string", VEDIT will search the remaining
help file for that string enclosed by backslashes "\". Once found, the
text following the "\string\" will be displayed.  The text will be
displayed until either another <CTRL-S> is reached or a backslash in
column one is reached.  The latter also ends the help command.
.sp
     Notice how the menu screens in VHELP.HLP are simply separated
by a <CTRL-S>.  Following the text for the menu screens is the text
for each topic which can be selected from the menu.  The first topic
is the "A" command.  Notice that a "\A\" appears just before the "A"
command description.  This is followed by a "\B\" and a description of
the "B" command.  This is repeated for each help topic.
.sp
     The text for a help topic usually ends with the backslash "\"
which starts the next topic.  However, the topic could display a
sub-menu ending with a <CTRL-S>.  Any user response would then be
used as a search string to a sub-topic. In this way the On-line help
can be hierarchical, with any desired number of sub-menus.
.sp
     One last feature pertains to the visual [HELP]
function and the associated VVHELP.HLP file.  Following the keyboard
layout menu, the user is prompted to press the control sequence
corresponding to the desired visual function.  If you edit the file
VVHELP.HLP you will notice that this prompt is followed by a <CTRL-V>.
The <CTRL-V> is similar to <CTRL-S> in that it stops the display and
waits for a user response.  With <CTRL-V>, however, the response is
expected to be a control sequence.  This control sequence is converted
into a two letter mnemonic code corresponding to the edit function it
performs.  This two letter code is then used as a search string in the
customary way.
.sp
     For example, the control sequence corresponding to [CURSOR UP] is
converted into the code "CU".  A "\CU\", therefore, appears at the
beginning of the help text for [CURSOR UP].  A response of just RETURN
is handled a little differently.  RETURN is also an edit function and
it has a code of "RT".  The second screen of the keyboard layout,
therefore, must begin with a "\RT\".  In effect, the second and third
menu screens are sub-menus.
.sp
     Any text file, such as a command reference for another program,
can be converted into a help file accessible from within VEDIT.  The
first step is to simply place <CTRL-S> "`IXstop character`IXs" within
the file after each screen full of text.  If you then rename the file
to be "VEHELP.HLP" the text will be viewable, one screen at a time,
via the "EH" command.  You do not even have to get fancy and use menus
with search strings.
.sp
     Actually, there is no need for a custom help file to be editing
oriented.  By using the menu and sub-menu features, you could create a
help system for virtually any topic, even non-computer topics.
.br

